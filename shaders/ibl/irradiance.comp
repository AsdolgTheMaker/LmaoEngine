#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform samplerCube envMap;
layout(set = 0, binding = 1, rgba16f) uniform writeonly imageCube irradianceMap;

const float PI = 3.14159265359;

vec3 cubeDir(int face, vec2 uv) {
    vec2 st = uv * 2.0 - 1.0;
    switch (face) {
        case 0: return normalize(vec3( 1.0, -st.y, -st.x));
        case 1: return normalize(vec3(-1.0, -st.y,  st.x));
        case 2: return normalize(vec3( st.x,  1.0,  st.y));
        case 3: return normalize(vec3( st.x, -1.0, -st.y));
        case 4: return normalize(vec3( st.x, -st.y,  1.0));
        case 5: return normalize(vec3(-st.x, -st.y, -1.0));
    }
    return vec3(0.0);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    int face = int(gl_GlobalInvocationID.z);
    ivec2 size = imageSize(irradianceMap).xy;

    if (pos.x >= size.x || pos.y >= size.y || face >= 6) return;

    vec2 uv = (vec2(pos) + 0.5) / vec2(size);
    vec3 N = cubeDir(face, uv);

    // Build tangent frame
    vec3 up = abs(N.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 right = normalize(cross(up, N));
    up = cross(N, right);

    // Cosine-weighted hemisphere sampling
    vec3 irradiance = vec3(0.0);
    float sampleCount = 0.0;

    const float deltaPhi = 2.0 * PI / 180.0;
    const float deltaTheta = 0.5 * PI / 64.0;

    for (float phi = 0.0; phi < 2.0 * PI; phi += deltaPhi) {
        for (float theta = 0.0; theta < 0.5 * PI; theta += deltaTheta) {
            vec3 tangentSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
            vec3 sampleDir = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N;

            irradiance += texture(envMap, sampleDir).rgb * cos(theta) * sin(theta);
            sampleCount += 1.0;
        }
    }
    irradiance = PI * irradiance / sampleCount;

    imageStore(irradianceMap, ivec3(pos, face), vec4(irradiance, 1.0));
}
